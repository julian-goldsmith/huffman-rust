use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use std::cmp::Ordering;

#[derive(Debug,Clone,Eq)]
struct Node {
    count: usize,
    val: char,
    left: Option<Box<Node>>,
    right: Option<Box<Node>>,
}

impl Ord for Node {
    fn cmp(&self, other: &Node) -> Ordering {
        self.count.cmp(&other.count)
    }
}

impl PartialOrd for Node {
    fn partial_cmp(&self, other: &Node) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Node {
    fn eq(&self, other: &Node) -> bool {
        self.count == other.count
    }
}

fn get_test_data() -> String {
    let path = Path::new("../testfile.txt");
    let display = path.display();

    let mut file = match File::open(&path) {
        Err(why) => panic!("couldn't open {}: {}", display,
                                                   why.description()),
        Ok(file) => file,
    };

    let mut s = String::new();
    match file.read_to_string(&mut s) {
        Err(why) => panic!("couldn't read {}: {}", display,
                                                   why.description()),
        Ok(_) => s,
    }
}

fn build_freq_list(data: &String) -> Vec<Node> {
    let mut nodes: Vec<Node> = vec![];

    for i in 0..256 {
        let val = i as u8 as char;
        let count = data.chars().filter(|c| *c == val).count();
        let node = Node { count: count, val: val, left: None, right: None };

        nodes.push(node)
    }

    nodes
}

fn build_tree<'a>(nodes: &'a mut Vec<Node>) -> Node {
    if nodes.len() == 1 {
        return nodes.pop().unwrap()
    };

    let left = nodes.pop().unwrap();
    let right = nodes.pop().unwrap();

    let new_node = Node { count: left.count + right.count, val: '\0', left: Some(Box::new(left)), right: Some(Box::new(right)) };
    nodes.push(new_node);
    
    build_tree(nodes)
}

fn main() {
    let data = get_test_data();

    let mut freqs = build_freq_list(&data);

    freqs.sort();

    let root = build_tree(&mut freqs);

    print!("{:?}", root)
}
