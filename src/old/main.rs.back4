use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use std::cmp::Ordering;

#[derive(Debug,Clone,Eq)]
struct Node {
    count: usize,
    val: char,
    left: Option<Box<Node>>,
    right: Option<Box<Node>>,
}

impl Ord for Node {
    fn cmp(&self, other: &Node) -> Ordering {
        self.count.cmp(&other.count)
    }
}

impl PartialOrd for Node {
    fn partial_cmp(&self, other: &Node) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Node {
    fn eq(&self, other: &Node) -> bool {
        self.count == other.count
    }
}

fn get_test_data() -> String {
    let path = Path::new("../testfile.txt");
    let display = path.display();

    let mut file = match File::open(&path) {
        Err(why) => panic!("couldn't open {}: {}", display,
                                                   why.description()),
        Ok(file) => file,
    };

    let mut s = String::new();
    match file.read_to_string(&mut s) {
        Err(why) => panic!("couldn't read {}: {}", display,
                                                   why.description()),
        Ok(_) => s,
    }
}

fn build_freq_list(data: &String) -> Vec<Node> {
    let mut nodes: Vec<Node> = vec![];

    for i in 0..256 {
        let val = i as u8 as char;
        let count = data.chars().filter(|c| *c == val).count();
        let node = Node { count: count, val: val, left: None, right: None };

        nodes.push(node)
    }

    nodes
}

fn build_tree<'a>(nodes: &'a mut Vec<Node>) -> Node {
    if nodes.len() == 1 {
        return nodes.pop().unwrap()
    };

    let left = nodes.pop().unwrap();
    let right = nodes.pop().unwrap();

    let new_node = Node { count: left.count + right.count, val: '\0', left: Some(Box::new(left)), right: Some(Box::new(right)) };
    nodes.push(new_node);
    
    build_tree(nodes)
}

// return None if char not found, string of bits if is
fn encode_char(root: &Node, c: &char, acc: &mut String) -> Option<String> {
    /*
    if root.left == None {
        if root.val == *c {
            return Some(acc.clone())
        } else {
            return None
        }
    }

    let mut leftacc = acc.clone() + &"0";
    let left = root.left;
    let leftval = encode_char(&left.unwrap(), c, &mut leftacc);

    if leftval != None {
        leftval
    } else {
        let mut rightacc = acc.clone() + &"1";
        let right = root.right.unwrap();
        encode_char(&right, c, &mut rightacc)
    }
    */





    match root.left {
        None => 
        {
            if root.val == *c {
                return Some(acc.clone())
            } else {
                return None
            }
        },
        Some(ref left) => {
            let mut leftacc = acc.clone() + &"0";
            let leftval = encode_char(&left, c, &mut leftacc);

            if leftval != None {
                leftval
            } else {
                let mut rightacc = acc.clone() + &"1";
                
                match root.right {
                    None => None,
                    Some(ref right) => encode_char(&right, c, &mut rightacc),
                }
            }
        },
    }
}

fn main() {
    let data = get_test_data();

    let mut freqs = build_freq_list(&data);

    freqs.sort();

    let root = build_tree(&mut freqs);

    //print!("{:?}", root)
    
    let c = 'a';
    let mut acc = String::from("");
    print!("{:?}", encode_char(&root, &c, &mut acc))
}
